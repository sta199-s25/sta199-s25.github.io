{
  "hash": "2406e1d0465025445a8666da9d215b50",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Lab 4\"\ndate: \"2025-02-10\"\nformat: revealjs\nauto-stretch: false\neditor_options: \n  chunk_output_type: console\n---\n\n\n\n## While you wait... get your repo ready {.smaller}\n\n::: appex\n-   Log in to RStudio (via your container)\n\n    -   Go to <https://cmgr.oit.duke.edu/containers> and click `STA198-199`\n\n-   Clone the repo & start a new RStudio project\n\n    -   Go to the course organization at [github.com/sta199-s25](https://github.com/sta199-s25) organization on GitHub. Click on the repo with the prefix **lab-4**.\n\n    -   Click on the green **CODE** button and select **Use SSH**. Click on the clipboard icon to copy the repo URL.\n\n    -   In RStudio, go to *File* ➛ *New Project* ➛*Version Control* ➛ *Git* to clone your Lab 4 repo.\n\n-   Update the YAML\n\n    -   In `lab-4.qmd`, update the `author` field to your name, **Render** your document, and examine the changes. Then, in the Git pane, click on **Diff** to view your changes, add a commit message (e.g., \"Added author name\"), and click **Commit**. Then, **Push** the changes to your GitHub repository and, in your browser, confirm that these changes have indeed propagated to your repository.\n:::\n\n::: notes\nShould look at Marie's notes again (from email on 1/22/25). There are more notes there to incorporate, especially in earlier labs with the motivation.\n:::\n\n## A review {.smaller}\n\nYou have learned a lot thus far\n\n-   Git/GitHub\n\n-   R\n\n    -   Plot related functions\n\n        `ggplot(), aes(), geom_boxplot(), geom_point(), geom_histogram(), geom_smooth(), geom_line(), geom_beeswarm(), labs(), theme_minimal(), theme() scale_x_continuous(), scale_color_manual()`\n\n    -   More functions\n\n        `glimpse(), nrow(), ncol(), dim(), slice_head(), filter(), arrange(), relocate(), if_else(), case_when(), count(), group_by(), ungroup(), read_csv(), separate(), mutate(), summarize(), pivot_*(), *_join()`\n\n::: notes\nGit/Github: had lots of practice pulling, committing and pushing changes to update your repos on GitHub.\n\nR: These functions were taken from ae-02 to ae-06 and the prepare videos (a good places to practice and refresh what you've learned).\n\n(optional, may not be enough time -- can transition by stating let's talk about a few of these in more detail) Have students raise hands to ask state these functions do (with an emphasis on those under more functions) -- just for 5 or so functions. Hopefully, multiple students raise their hands. Otherwise you can simply move on.\n\nTransition: now let's do a more thorough review of some of these functions\n:::\n\n## `mutate()` and `summarize()` {.smaller}\n\n \n\n \n\n-   `mutate()`: modifies existing data frame -- creates new columns (i.e., variables) or modifies existing columns. Note that the number of rows does not change.\n\n \n\n-   `summarize()`: creates a new data frame -- returns one for for each combination of grouping variables. If there is no grouping it will have a single row summarizing all observations\n\n## Example: Set up {.smaller}\n\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(knitr)\n\ndf <- tibble(\n  col_1 = c(\"A\", \"A\", \"A\", \"B\", \"B\"),\n  col_2 = c(\"X\", \"Y\", \"X\", \"X\", \"Y\"),\n  col_3 = c(1, 2, 3, 4, 5)\n)\n\ndf #this is used to display the data frame\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 3\n  col_1 col_2 col_3\n  <chr> <chr> <dbl>\n1 A     X         1\n2 A     Y         2\n3 A     X         3\n4 B     X         4\n5 B     Y         5\n```\n\n\n:::\n:::\n\n\n\n. . .\n\nWhat would be the result of the following code? \\# rows? \\# cols? column/variable names?\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |>\n  mutate(med_col_3 = median(col_3))\n\n\ndf |>\n  summarize(med_col_3 = median(col_3))\n```\n:::\n\n\n\n::: notes\nHAVE THE STUDENTS GUESS how many rows, columns, what the variable names will be?\n\nmutate: number of rows does not change, number of columns increases by 1 (`med_col_3`). Could have also introduced more new variables within the mutate function using commas,\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |>\n  mutate(\n    med_col_3 = median(col_3),\n    mean_col_3 = mean(col_3)\n    )\n```\n:::\n\n\n\nsummarize: there is only 1 row and 1 col! (this is a much different data frame than df!). Could have had more columns/variables if added more variables within summarize function using commas. \\[same as above, just replace mutate with summarize\\]\n\nassignment: have the students guess\n:::\n\n## Example: no groups {.smaller}\n\n`mutate()`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |>\n  mutate(med_col_3 = median(col_3))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 4\n  col_1 col_2 col_3 med_col_3\n  <chr> <chr> <dbl>     <dbl>\n1 A     X         1         3\n2 A     Y         2         3\n3 A     X         3         3\n4 B     X         4         3\n5 B     Y         5         3\n```\n\n\n:::\n:::\n\n\n\n. . .\n\n`summarize()`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |>\n  summarize(med_col_3 = median(col_3))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 1\n  med_col_3\n      <dbl>\n1         3\n```\n\n\n:::\n:::\n\n\n\n. . .\n\nWe did not assign any new or existing data frames (e.g., no `??? <-`). In particular, we did not write over `df` (i.e., no `df <-`), so what will be the result of the following code?\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf\n```\n:::\n\n\n\n::: notes\nmutate: there was no column named `med_col_3`, so a new column was created\n\nsummarize: there is no grouping, so there is one output summarizing so the median is computed over all of the original rows of the data (five rows in this example)\n\nassignment: have the students guess\n:::\n\n## Example: assignment {.smaller}\n\n-   It's the same as when it was originally assigned. It has not been overwritten!\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 3\n  col_1 col_2 col_3\n  <chr> <chr> <dbl>\n1 A     X         1\n2 A     Y         2\n3 A     X         3\n4 B     X         4\n5 B     Y         5\n```\n\n\n:::\n:::\n\n\n\n. . .\n\n-   We will often write a single pipeline and show the result, i.e., no assignment.\n\n-   If you will need to refer to the data frame later, it might be a good idea to assign a name to the data frame. Otherwise, see the result and continue on.\n\n    ##### Note: if you assign the new/updated data frame, the result does not appear in the `Console` or the rendered document! (Type the name of the variable, e.g., `df` as shown above, to display the data frame.)\n\n## Example: with groups {.smaller}\n\nWhat if there is grouping?\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# group by 1 variable\ndf |>\n  group_by(col_1) |>\n  mutate(med_col_3 = median(col_3))\n\n\ndf |>\n  group_by(col_1) |>\n  summarize(med_col_3 = median(col_3))\n\n# group by 2 variables\ndf |>\n  group_by(col_1, col_2) |>\n  mutate(med_col_3 = median(col_3))\n\n\ndf |>\n  group_by(col_1, col_2) |>\n  summarize(med_col_3 = median(col_3))\n```\n:::\n\n\n\n. . .\n\nIf you aren't sure, try it out and see what happens (e.g., use data frame from Lab 3, Part 1).\n\n::: notes\nI would have written this out in Lab 3 prep. But there is other stuff to get to for Lab 4 prep that I didn't want this to take up too much of the time. Plus, by now they saw what happened already in Lab 3.\n\nAlso, make a comment about the grouping when expanding upon this next semester.\n:::\n\n## `pivot_*()`\n\n-   Pivoting reshapes the data frame.\n\n-   `pivot_longer` makes the updated data frame **longer** (i.e., fewer columns)\n\n-   `pivot_wider` makes the updated data frame **wider** (i.e., more columns)\n\n## Example: `pivot_*()` {.smaller}\n\nLet's examine the number of hours people slept during the week.\n\n:::::: {style=\"font-size: 70%;\"}\n::::: columns\n::: {.column width=\"65%\"}\n> How do we go from this...\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n\n\n|ppl     | Mon| Tues| Weds| Thurs| Fri|\n|:-------|---:|----:|----:|-----:|---:|\n|person1 |   8|    7|    6|    10|   8|\n|person2 |   7|    5|    4|     6|   7|\n\n\n:::\n:::\n\n\n:::\n\n::: {.column width=\"35%\"}\n> ...to this?\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n\n\n|ppl     |day   | hours|\n|:-------|:-----|-----:|\n|person1 |Mon   |     8|\n|person1 |Tues  |     7|\n|person1 |Weds  |     6|\n|person1 |Thurs |    10|\n|person1 |Fri   |     8|\n|person2 |Mon   |     7|\n|person2 |Tues  |     5|\n|person2 |Weds  |     4|\n|person2 |Thurs |     6|\n|person2 |Fri   |     7|\n\n\n:::\n:::\n\n\n:::\n:::::\n::::::\n\n. . .\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_longer <- df |>\n  pivot_longer(\n    cols = -ppl,\n    names_to = \"day\",\n    values_to = \"hours\"\n  )\n```\n:::\n\n\n\n::: notes\n`pivot_longer()` or `pivot_wider()`? Have the students vote. `pivot_longer()`!\n\nWhat should the arguments be? (Go through the argument discussion first, then reveal the result toward the end -- giving them enough time to look at it for visual learners)\n\n`cols = -ppl`: `cols` -- the columns to be pivoted (i.e., stacked into rows). in this case all of the columns except `ppl` (`ppl` column/variable remains)\n\n`names_to = \"day\"`: `names_to` -- the new column/variable name for the original column/variable names \\[point to the Mon, Tues, Weds, ... in the original table\\]\n\n`values_to = \"hours\"`: `names_to` -- the new column/variable name for the values from the original data \\[point to the hours of sleep in the original table\\]\n\nNote that the column/variable names \"day\" and \"hours\" did not exist until using `pivot_longer()`\n\nQuestion: What if I hadn't assigned the result to `df_longer`? What would the display look like and what would the `df` data frame be if I had deleted the `df_longer <-` portion of the code?\n\nAnswer: The console would show the data frame `df_longer` (though it wouldn't be named -- it would just read `# A tibble: 10 x 3` and so on), and `df` remains unchanged. It's the same wide (2 x 6) tibble it originally was defined as.\n:::\n\n## `*_join()` {.smaller}\n\n-   Typically we use `*_join()` to merge data from two data frames (e.g., `left_join()`, `right_join()`, `full_join()`, `inner_join()`), i.e., create a new data frames with more columns/variables.\n\n    For example, there is useful info in two data frames: `x` and `y`. We want to create a new data frame which includes variables from both (e.g., data frame `x` has student ID numbers and student names and data frame `y` has student ID numbers and email addresses).\n\n. . .\n\n-   Sometimes we use `*_join()` to filter rows/observations, e.g., find the rows from one data frame that do (or do not) exist in another data frame (e.g., `semi_join()`, `anti_join()`)\n\n. . .\n\n-   Let's focus on the joins that merge data...\n\n## Example: `*_join()` setup {.smaller}\n\nFor the next few slides...\n\n::::: columns\n::: {.column width=\"50%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- tibble(\n  id = c(1, 2, 3),\n  value_x = c(\"x1\", \"x2\", \"x3\")\n  )\n\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 2\n     id value_x\n  <dbl> <chr>  \n1     1 x1     \n2     2 x2     \n3     3 x3     \n```\n\n\n:::\n:::\n\n\n:::\n\n::: {.column width=\"50%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny <- tibble(\n  id = c(1, 2, 4),\n  value_y = c(\"y1\", \"y2\", \"y4\")\n  )\n\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 2\n     id value_y\n  <dbl> <chr>  \n1     1 y1     \n2     2 y2     \n3     4 y4     \n```\n\n\n:::\n:::\n\n\n:::\n:::::\n\n## `left_join()`\n\n::::: columns\n::: {.column width=\"50%\"}\n![](images/07/left-join.gif)\n:::\n\n::: {.column width=\"50%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nleft_join(x, y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 3\n     id value_x value_y\n  <dbl> <chr>   <chr>  \n1     1 x1      y1     \n2     2 x2      y2     \n3     3 x3      <NA>   \n```\n\n\n:::\n:::\n\n\n:::\n:::::\n\nKeep all rows from left data frame.\n\n## `right_join()`\n\n::::: columns\n::: {.column width=\"50%\"}\n![](images/07/right-join.gif)\n:::\n\n::: {.column width=\"50%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nright_join(x, y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 3\n     id value_x value_y\n  <dbl> <chr>   <chr>  \n1     1 x1      y1     \n2     2 x2      y2     \n3     4 <NA>    y4     \n```\n\n\n:::\n:::\n\n\n:::\n:::::\n\n  Keep all rows from right data frame.\n\n## `full_join()`\n\n::::: columns\n::: {.column width=\"50%\"}\n![](images/07/full-join.gif)\n:::\n\n::: {.column width=\"50%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfull_join(x, y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 3\n     id value_x value_y\n  <dbl> <chr>   <chr>  \n1     1 x1      y1     \n2     2 x2      y2     \n3     3 x3      <NA>   \n4     4 <NA>    y4     \n```\n\n\n:::\n:::\n\n\n:::\n:::::\n\n \n\nKeep all rows from both data frames.\n\n## `inner_join()`\n\n::::: columns\n::: {.column width=\"50%\"}\n![](images/07/inner-join.gif)\n:::\n\n::: {.column width=\"50%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninner_join(x, y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 3\n     id value_x value_y\n  <dbl> <chr>   <chr>  \n1     1 x1      y1     \n2     2 x2      y2     \n```\n\n\n:::\n:::\n\n\n:::\n:::::\n\n \n\nKeep all rows that exist in both data frames.\n\n## Example: `*_join()` more info {.smaller}\n\n-   We could also use `*_join()` within a pipeline.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx |>\n  left_join(y)\n```\n:::\n\n\n\n-   Which data frame is on the left and which is on the right? `x` or `y`?\n\n. . .\n\n-   The above code is equivalent to `left_join(x, y)` since the result before the pipe `|>` is passed as the **first** argument to the function after the pipe.\n\n. . .\n\n-   In this example `x` has 2 variables: `id` and `value_x` and y has 2 variables: `id` and `value_x`, so there was only one common variable between `x` and `y` -- `id`. We could have been more explicit and used the following code\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nleft_join(x, y, by = join_by(id))\n\n# or alternatively\n\nleft_join(x, y, by = join_by(id == id))\n```\n:::\n\n\n\n::: notes\nThe first option is useful when there are multiple matching columns \\[and by default `*_join()` will use all variables in common across `x` and `y`\\] but perhaps only one of interest (e.g., `student_ids` and `email_address` -- the same student could have multiple email addresses but you want each student to be one row/observation, so you would use `by = join_by(student_ids)`).\n\nThe second option is used when the variables do not share the same variable name but are referring to the same information, e.g., `id == student_id`.\n\nBackup info: why piping? piping is much easier to read (can see all data frame manipulation at once -- and it isn't an extreme run-on sentence, e.g., summarize(mutatate(), arg, arg, arg....); also, potentially less having to save and remember intermediate variables) -- both for you and others.\n:::\n\n## Factors {.smaller}\n\n-   Factors are used for categorical variables, e.g., days of the week; religion; low, mid, high\n\n-   Very helpful for ordering (i.e., when numerical and alphabetical ordering don't cut it!)\n\n. . .\n\n-   Examples\n\n    -   Friday, Monday, Saturday, Sunday, Tuesday, Thursday, Wednesday\n\n    -   Apr, Feb, Jan, July, Jun, Mar, May\n\n    -   Agree, Disagree, Neither agree nor disagree, Strongly agree, Strongly disagree\n\n    -   Example below (from prepare \\[r4ds\\] chp 16.4)\n\n::::: columns\n::: {.column width=\"50%\"}\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](lab-4_files/figure-revealjs/unnamed-chunk-21-1.png){width=960}\n:::\n:::\n\n\n:::\n\n::: {.column width=\"50%\"}\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](lab-4_files/figure-revealjs/unnamed-chunk-22-1.png){width=960}\n:::\n:::\n\n\n:::\n:::::\n\n## Factor example {.smaller}\n\n\n\n::: {.cell}\n\n:::\n\n\n\nRecall from Thursday's lecture\n\n::::: columns\n::: {.column width=\"50%\"}\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](lab-4_files/figure-revealjs/unnamed-chunk-24-1.png){width=960}\n:::\n:::\n\n\n:::\n\n::: {.column width=\"50%\"}\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](lab-4_files/figure-revealjs/unnamed-chunk-25-1.png){width=960}\n:::\n:::\n\n\n:::\n:::::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsurvey |>\n  mutate(\n    year = fct_relevel(year, \"First-year\", \"Sophomore\", \"Junior\", \"Senior\")\n    ) |>\n  ggplot(aes(x = year)) +\n  geom_bar() + \n  labs(\n    title = \"Number of students by year\",\n    x = \"Year\",\n    y = \"Count\"\n  )\n```\n:::\n\n\n\n. . .\n\n::: question\nHow is the x-axis ordered in the left and right plots?\n:::\n\n::: notes\nRecall from Thursday's lecture, using context we know about the data it's more appropriate for the `year` to have the order: first-year, sophomore, junior, senior and we used `fct_revel` to manually (we explicityly wrote out the order) change the ordering of the `year` variable.\n\nThe data is ordered alphabetically on the left (default for ggplot to order numerically or alphabetically).\n\nOrdered according to `fct_relevel` ordering on the right\n\nAlso that `fct_revel` did two things: it made the `year` variable a factor AND it set the order. (aside if asked) Note that ggplot will by default coerce the character variable to be a factor. Regardless if you assigned the data frame after running `fct_revel` it will be a factor (and you don't need to separately use the `factor()` function).\n:::\n\n## This week's lab {.smaller}\n\n-   Gain more experience with joining and pivoting data frames; and modifying the order of factors.\n\n-   Review Quarto cell options\n\n-   Learn to read data in from Excel spreadsheets (will learn more on Tuesday about this)\n\n-   Datasets\n\n    -   More inflation!\n\n    -   2020 and 2024 US Olympic Team rosters\n\n    -   Survey regarding medical marijuana in NC\n\n    -   `mtcars` from 1974 Motor Trend US magazine\n\n",
    "supporting": [
      "lab-4_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}